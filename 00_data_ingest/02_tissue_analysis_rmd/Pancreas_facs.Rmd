---
title: "Pancreas FACS Notebook"
output: html_notebook
---

Enter the directory of the maca folder on your drive and the name of the tissue you want to analyze.

```{r}
tissue_of_interest = "Pancreas"
```

Load the requisite packages and some additional helper functions.

```{r}
library(here)
library(useful)
library(Seurat)
library(dplyr)
library(Matrix)

save_dir = here('00_data_ingest', 'tissue_robj')
```


```{r}
# read the metadata to get the plates we want
plate_metadata_filename = here('00_data_ingest', '00_facs_raw_data', 'metadata_FACS.csv')

plate_metadata <- read.csv(plate_metadata_filename, sep=",", header = TRUE)
colnames(plate_metadata)[1] <- "plate.barcode"
plate_metadata
```

Subset the metadata on the tissue.

```{r}
tissue_plates = filter(plate_metadata, tissue == tissue_of_interest)[,c('plate.barcode','tissue','subtissue','mouse.sex')]
tissue_plates
```

Load the read count data.
```{r}
#Load the gene names and set the metadata columns by opening the first file
filename = here('00_data_ingest', '00_facs_raw_data', 'FACS', paste0(tissue_of_interest, '-counts.csv'))

raw.data = read.csv(filename, sep=",", row.names=1)
# raw.data = data.frame(row.names = rownames(raw.data))
corner(raw.data)
```
Make a vector of plate barcodes for each cell

```{r}
plate.barcodes = lapply(colnames(raw.data), function(x) strsplit(strsplit(x, "_")[[1]][1], '.', fixed=TRUE)[[1]][2])
head(plate.barcodes)
```

Use only the metadata rows corresponding to Bladder plates. Make a plate barcode dataframe to "expand" the per-plate metadata to be per-cell.
```{r}
barcode.df = t.data.frame(as.data.frame(plate.barcodes))

rownames(barcode.df) = colnames(raw.data)
colnames(barcode.df) = c('plate.barcode')
head(barcode.df)

rnames = row.names(barcode.df)
meta.data <- merge(barcode.df, plate_metadata, by='plate.barcode', sort = F)
row.names(meta.data) <- rnames

# Sort cells by plate barcode because that's how the data was originally
meta.data = meta.data[order(meta.data$plate.barcode), ]
corner(meta.data)
raw.data = raw.data[, rownames(meta.data)]
corner(raw.data)
```

Process the raw data and load it into the Seurat object.

```{r}
# Find ERCC's, compute the percent ERCC, and drop them from the raw data.
erccs <- grep(pattern = "^ERCC-", x = rownames(x = raw.data), value = TRUE)
percent.ercc <- Matrix::colSums(raw.data[erccs, ])/Matrix::colSums(raw.data)
ercc.index <- grep(pattern = "^ERCC-", x = rownames(x = raw.data), value = FALSE)
raw.data <- raw.data[-ercc.index,]

# Create the Seurat object with all the data
tiss <- CreateSeuratObject(raw.data = raw.data, project = tissue_of_interest, 
                    min.cells = 1, min.genes = 0)

tiss <- AddMetaData(object = tiss, meta.data)
tiss <- AddMetaData(object = tiss, percent.ercc, col.name = "percent.ercc")
# Change default name for sums of counts from nUMI to nReads
colnames(tiss@meta.data)[colnames(tiss@meta.data) == 'nUMI'] <- 'nReads'

# Create metadata columns for annotations and subannotations
tiss@meta.data[,'free_annotation'] <- NA
tiss@meta.data[,'cell_ontology_class'] <- NA
```

Calculate percent ribosomal genes.

```{r}
ribo.genes <- grep(pattern = "^Rp[sl][[:digit:]]", x = rownames(x = tiss@data), value = TRUE)
percent.ribo <- Matrix::colSums(tiss@raw.data[ribo.genes, ])/Matrix::colSums(tiss@raw.data)
tiss <- AddMetaData(object = tiss, metadata = percent.ribo, col.name = "percent.ribo")
```

A sanity check: genes per cell vs reads per cell.

```{r}
GenePlot(object = tiss, gene1 = "nReads", gene2 = "nGene", use.raw=T)
```

Filter out cells with few reads and few genes.

```{r}
tiss <- FilterCells(object = tiss, subset.names = c("nGene", "nReads"), 
    low.thresholds = c(500, 50000))
```


Normalize the data, then regress out correlation with total reads
```{r}
tiss <- NormalizeData(object = tiss, scale.factor = 1e6)
tiss <- ScaleData(object = tiss)

#tiss <- ScaleData(object = tiss, vars.to.regress = c("nReads", "percent.ribo","Rn45s"))
tiss <- FindVariableGenes(object = tiss, do.plot = TRUE, x.high.cutoff = Inf, y.cutoff = 0.5)
```


Run Principal Component Analysis.
```{r}
tiss <- RunPCA(object = tiss, do.print = FALSE)
tiss <- ProjectPCA(object = tiss, do.print = FALSE)
```

```{r, echo=FALSE, fig.height=4, fig.width=8}
PCHeatmap(object = tiss, pc.use = 1:3, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, num.genes = 8)
```

Later on (in FindClusters and TSNE) you will pick a number of principal components to use. This has the effect of keeping the major directions of variation in the data and, ideally, supressing noise. There is no correct answer to the number to use, but a decent rule of thumb is to go until the plot plateaus.

```{r}
PCElbowPlot(object = tiss)
```

Choose the number of principal components to use.
```{r}
# Set number of principal components. 
n.pcs = 11
```


The clustering is performed based on a nearest neighbors graph. Cells that have similar expression will be joined together. The Louvain algorithm looks for groups of cells with high modularity--more connections within the group than between groups. The resolution parameter determines the scale. Higher resolution will give more clusters, lower resolution will give fewer.

For the top-level clustering, aim to under-cluster instead of over-cluster. It will be easy to subset groups and further analyze them below.

```{r}
# Set resolution 
res.used <- 0.5

tiss <- FindClusters(object = tiss, reduction.type = "pca", dims.use = 1:n.pcs, 
    resolution = res.used, print.output = 0, save.SNN = TRUE)
```

To visualize, we use TSNE.
```{r}
# If cells are too spread out, you can raise the perplexity. If you have few cells, try a lower perplexity (but never less than 10).
tiss <- RunTSNE(object = tiss, dims.use = 1:n.pcs, seed.use = 10, perplexity=30)
```

```{r}
TSNEPlot(object = tiss, do.label = T, pt.size = 1.2, label.size = 4)
```

Check expression of genes useful for indicating cell type. For the islet cells, the mRNA for their specific secretory molecule is a strong signal.

general endocrine: Chga, Isl1
alpha: Gcg, Mafb, Arx
beta: Ins1, Ins2, Mafa, Nkx6-1
gamma: Ppy
delta: Sst, Hhex
epsilon: Ghrl
ductal: Krt19, Hnf1b
immune: Ptprc
stellate: Pdgfra, Pdgfrb
endothelial: Pecam1
exocrine: Amy2b, Cpa1
other genes of interest: Cpa1, Neurog3, Ptf1a, Pdx1

```{r, echo=FALSE, fig.height=12, fig.width=12}
genes_to_check = c('Chga', 'Isl1', 'Ins1', 'Ins2', 'Mafa', 'Nkx6-1', 'Gcg', 'Mafb', 'Arx', 'Sst', 'Hhex', 'Ppy',
                   'Ghrl', 'Krt19', 'Hnf1b', 'Ptprc', 'Pdgfra', 'Pdgfrb', 'Pecam1', 'Amy2b', 'Cpa1', 'Neurog3', 'Ptf1a', 'Pdx1')
FeaturePlot(tiss, genes_to_check, pt.size = 1, nCol = 5, cols.use = c("grey", "blue"))
```

Dotplots let you see the intensity of exppression and the fraction of cells expressing for each of your genes of interest.
The radius shows you the percent of cells in that cluster with at least one read sequenced from that gene. The color level indicates the average
Z-score of gene expression for cells in that cluster, where the scaling is done over taken over all cells in the sample.

```{r, echo=FALSE, fig.height=8, fig.width=10}
DotPlot(tiss, genes_to_check, plot.legend = T, col.max = 2.5, do.return = T) + coord_flip()
```

We can also find all differentially expressed genes marking each cluster. This may take some time.

```{r}
tiss.markers <- FindAllMarkers(object = tiss, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
```

Display the top markers you computed above.
```{r}
tiss.markers %>% group_by(cluster) %>% top_n(5, avg_diff)
```

Using the markers above, we can confidentaly label many of the clusters:

0: beta
3: exocrine
4: ductal
6: beta
7: endothelial
8: immune
9: stellate

The abundance of Ppy and Gcg in clusters 1 and 2 makes them seem like mixtures of alpha and delta cells. The expression of Sst and Hhex in cluster 5
indicates that it might contain many gamma cells, but to get a finer resolution, we subset the data and recompute.

We will add those annotations to the dataset.

```{r}
tiss <- StashIdent(object = tiss, save.name = "cluster.ids")

cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

free_annotation <- c(
  "beta cell", 
   NA, 
   NA, 
   "exocrine cell", 
   "ductal cell", 
   NA, "beta cell", 
   "endothelial cell", 
   "immune cell", 
   "stellate cell")

cell_ontology_class <- c(
  "type B pancreatic cell", 
   NA, 
   NA, 
   "pancreatic acinar cell", 
   "pancreatic ductal cell", 
   NA, 
   "type B pancreatic cell", 
   "endothelial cell", 
   "leukocyte", 
   "pancreatic stellate cell")

tiss@meta.data['free_annotation'] <- as.character(plyr::mapvalues(x = tiss@ident, from = cluster.ids, to = free_annotation))
tiss@meta.data['cell_ontology_class'] <- as.character(plyr::mapvalues(x = tiss@ident, from = cluster.ids, to = cell_ontology_class))
```


## Subcluster

```{r}
subtiss = SubsetData(tiss, ident.use = c(1,2,5))
```

```{r}
subtiss <- subtiss %>% ScaleData() %>% 
  FindVariableGenes(do.plot = TRUE, x.high.cutoff = Inf, y.cutoff = 0.5) %>%
  RunPCA(do.print = FALSE)
```

```{r}
PCHeatmap(object = subtiss, pc.use = 1:3, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, num.genes = 8)
PCElbowPlot(subtiss)
```


```{r}
sub.n.pcs = 6
sub.res.use = 1
subtiss <- subtiss %>% FindClusters(reduction.type = "pca", dims.use = 1:sub.n.pcs, 
    resolution = sub.res.use, print.output = 0, save.SNN = TRUE) %>%
    RunTSNE(dims.use = 1:sub.n.pcs, seed.use = 10, perplexity=30)

TSNEPlot(object = subtiss, do.label = T, pt.size = 1.2, label.size = 4)

```

```{r, echo=FALSE, fig.height=12, fig.width=8}
FeaturePlot(subtiss, genes_to_check)
```

```{r, echo=FALSE, fig.height=12, fig.width=12}
DotPlot(subtiss, genes_to_check)
```

From these genes, it appears that the clusters represent:

0: TKTK
1:
2:
3:
4:
5:
6:
7:


```{r}
TSNEPlot(object = subtiss, group.by = 'mouse.id', do.label = T, pt.size = 1.2, label.size = 4)
```

```{r}
table(FetchData(subtiss, c('mouse.id','ident')) %>% droplevels())
```

```{r}
sub.cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7)
sub.annotation <- c("pancreatic A cell", "pancreatic A cell", "pancreatic A cell", "pancreatic D cell", "pancreatic A cell", "pancreatic D cell", "pancreatic PP cell", "pancreatic PP cell")

subtiss@meta.data['annotation'] <- plyr::mapvalues(x = subtiss@ident, from = sub.cluster.ids, to = sub.annotation)
```

```{r}
DotPlot(subtiss, genes.plot = genes_to_check_TF, group.by = 'annotation')
```

```{r}
GenePlot(subtiss, 'Gcg', 'Ppy')
```

```{r}
FetchData(subtiss, c('annotation','nReads')) %>% 
  ggplot(aes(nReads, colour = annotation)) + 
  geom_freqpoly(binwidth = 2e5) 
```

```{r}
FetchData(subtiss, c('annotation','percent.ribo')) %>% 
  ggplot(aes(percent.ribo,colour = annotation)) + 
  geom_freqpoly(binwidth = 0.005) 
```

```{r}
FetchData(subtiss, c('annotation','Rn45s')) %>% 
  ggplot(aes(Rn45s, colour = annotation)) + 
  geom_freqpoly() 
```

```{r}
FetchData(tiss, c('ident','nReads')) %>% 
  ggplot(aes(nReads, ..density..,colour = ident)) + 
  facet_wrap(~ident) + 
  geom_freqpoly() 
```

## Assigning cell type identity to clusters

At a coarse level, we can use canonical markers to match the unbiased clustering to known cell types:

0: alpha
1: beta
2: beta
3: exocrine
4: duct
5: delta
6: gamma
7: endothelial
8: immune
9: stellate

```{r}
# stash current cluster IDs
tiss <- StashIdent(object = tiss, save.name = "cluster.ids")

# enumerate current cluster IDs and the labels for them
cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
annotation <- c("pancreatic A cell", "type B pancreatic cell", "type B pancreatic cell", "pancreatic acinar cell", "pancreatic ductal cell", "pancreatic D cell", "pancreatic PP cell", "endothelial cell", "leukocyte", "pancreatic stellate cell")
cell_ontology_id <- c("CL:0000171", "CL:0000169", "CL:0000169", "CL:0002064", "CL:0002079", "CL:0000173", "CL:0002275", "CL:0000115", "CL:0000738", "CL:0002410")

tiss@meta.data[,'annotation'] <- plyr::mapvalues(x = tiss@ident, from = cluster.ids, to = annotation)
tiss@meta.data[,'cell_ontology_id'] <- plyr::mapvalues(x = tiss@ident, from = cluster.ids, to = cell_ontology_id)

tiss@meta.data[tiss@cell.names,'annotation'] <- as.character(tiss@meta.data$annotation)
tiss@meta.data[tiss@cell.names,'cell_ontology_id'] <- as.character(tiss@meta.data$cell_ontology_id)

TSNEPlot(object = tiss, do.label = TRUE, pt.size = 1.2, group.by='annotation')
```

```{r}
JoyPlot(object = tiss, features.plot = c("Gcg", "Ppy"), group.by='annotation')
```




```{r}
GenePlot(tiss, "Gcg","Ppy")
```


## Checking for batch effects

Color by metadata, like plate barcode, to check for batch effects.
```{r}
TSNEPlot(object = tiss, do.return = TRUE, group.by = "plate.barcode")
```

Print a table showing the count of cells in each identity category from each plate.

```{r}
table(as.character(tiss@ident), as.character(tiss@meta.data$plate.barcode))
```

# Save the Robject for later
When you save the annotated tissue, please give it a name.

```{r}
filename = here('00_data_ingest', '04_tissue_robj_generated', 
                     paste0("facs", tissue_of_interest, "_seurat_tiss.Robj"))
print(filename)
save(tiss, file=filename)
```

```{r}
# To reload a saved object
# filename = here('00_data_ingest', '04_tissue_robj_generated', 
#                      paste0("facs", tissue_of_interest, "_seurat_tiss.Robj"))
# load(file=filename)
```



# Export the final metadata

So that Biohub can easily combine all your annotations, please export them as a simple csv.

```{r}
head(tiss@meta.data)
```


```{r}
filename = here('00_data_ingest', '03_tissue_annotation_csv', 
                     paste0(tissue_of_interest, "_annotation.csv"))
write.csv(tiss@meta.data[,c('plate.barcode','annotation','cell_ontology_id')], file=filename)
```
