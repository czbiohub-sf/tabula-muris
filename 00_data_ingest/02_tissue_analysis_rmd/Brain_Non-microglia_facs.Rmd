---
title: "Brain Non-microglia FACS Notebook"
 output: html_notebook
---

Specify the tissue of interest, run the boilerplate code which sets up the functions and environment, load the tissue object.

```{r}
tissue_of_interest = "Brain_Non-microglia"
library(here)
source(here("00_data_ingest", "02_tissue_analysis_rmd", "boilerplate.R"))
tiss = load_tissue_facs(tissue_of_interest)
```

Visualize top genes in principal components

```{r, echo=FALSE, fig.height=4, fig.width=8}
PCHeatmap(object = tiss, pc.use = 1:3, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, num.genes = 8)
```

Later on (in FindClusters and TSNE) you will pick a number of principal components to use. This has the effect of keeping the major directions of variation in the data and, ideally, supressing noise. There is no correct answer to the number to use, but a decent rule of thumb is to go until the plot plateaus.

```{r}
PCElbowPlot(object = tiss)
```

Choose the number of principal components to use.
```{r}
# Set number of principal components. 
n.pcs = 12
```


The clustering is performed based on a nearest neighbors graph. Cells that have similar expression will be joined together. The Louvain algorithm looks for groups of cells with high modularity--more connections within the group than between groups. The resolution parameter determines the scale...higher resolution will give more clusters, lower resolution will give fewer.

For the top-level clustering, aim to under-cluster instead of over-cluster. It will be easy to subset groups and further analyze them below.

```{r}
# Set resolution 
res.used <- 0.4
tiss <- FindClusters(object = tiss, reduction.type = "pca", dims.use = 1:n.pcs, 
    resolution = res.used, print.output = 0, save.SNN = TRUE, k.param = 50)
#tiss <- FindClusters(object = tiss, reduction.type = "pca", dims.use = 1:n.pcs, resolution = res.used, print.output = 0, save.SNN = TRUE)
#table(tiss@meta.data$res.0.4)
```

To visualize 
```{r}
# If cells are too spread out, you can raise the perplexity. If you have few cells, try a lower perplexity (but never less than 10).

tiss <- RunTSNE(object = tiss, dims.use = 1:n.pcs, seed.use = 10, perplexity=50)
```

```{r}
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = tiss, do.label = T)
TSNEPlot(object = tiss, group.by='subtissue')
TSNEPlot(object = tiss, group.by='mouse.id')
TSNEPlot(object = tiss, do.label = T, pt.size = 1.2, label.size = 4)
```

Check expression of genes of interset.

```{r, echo=FALSE, fig.height=12, fig.width=8}
genes_to_check = c("Mog","Mobp" ,"Mbp", "Pecam1", "Cldn5", "Ly6c1", "Aqp4", "Aldh1l1","Slc1a3", "Snap25","Eno2", "Rbfox3","Pdgfra","Susd5", "Cspg4", "Pdgfrb","Mcam", "Des", "Ascl1", "Dcx", "Dlx2","Gad1","Reln", "Calb1", "Slc17a7", "Neurod6", "Mab21l1")
TSNEPlot(object = tiss, do.label = T)
FeaturePlot(tiss, genes_to_check, pt.size = 1, nCol = 3)
DotPlot(tiss, genes_to_check, plot.legend = T, col.max = 2.5, do.return = T) + coord_flip()
```

You can also compute all markers for all clusters at once. This may take some time.
```{r}
tiss.markers <- FindAllMarkers(object = tiss, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
top_genes <- tiss.markers %>% group_by(cluster) %>% top_n(50, avg_diff)
cluster.averages <- AverageExpression(object = tiss)
```
Dotplots let you see the intensity of exppression and the fraction of cells expressing for each of your genes of interest.

```{r, echo=FALSE, fig.height=4, fig.width=8}
# To change the y-axis to show raw counts, add use.raw = T.
top_genes <- tiss.markers %>% group_by(cluster) %>% top_n(5, avg_diff)
genes_to_check <- top_genes$gene
```


How big are the clusters?
```{r}
table(tiss@ident)
```

Which markers identify a specific cluster?

```{r}
clust.markers <- FindMarkers(object = tiss, ident.1 = 0, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
```

```{r}
print(x = head(x= clust.markers, n = 10))
```

## Assigning cell type identity to clusters

At a coarse level, we can use canonical markers to match the unbiased clustering to known cell types:

oligodendrocytes- "Mog","Mobp" ,"Mbp
endothelial- "Pecam1", "Cldn5", "Ly6c1"
astrocytes- "Aqp4", "Aldh1l1","Slc1a3"
OPCs- "Pdgfra","Susd5", "Cspg4"
pericytes- "Pdgfrb","Mcam", "Des"
pan-neuronal markers- "Snap25","Eno2", "Rbfox3"
inhibitory neurons- "Gad1","Reln", "Calb1",
inhibitory neurons- "Slc17a7", "Neurod6", "Mab21l1"
NPCs- "Ascl1", "Dcx", "Dlx2"

```{r}
library(tidyverse)
figshare_annotation = read_csv(here("00_data_ingest","00_facs_raw_data", "annotations_FACS.csv"))
figshare_annotation = filter(figshare_annotation, tissue == tissue_of_interest)
tiss@meta.data[, 'figshare_annotation'] <- NA
tiss@meta.data[as.character(figshare_annotation$cell), 'figshare_annotation'] <- as.character(figshare_annotation$cell_ontology_class)
TSNEPlot(object = tiss, do.return = TRUE, group.by = "figshare_annotation")
```

```{r}
table(tiss@meta.data$figshare_annotation, tiss@ident)
```


```{r}
# stash current cluster IDs
tiss <- StashIdent(object = tiss, save.name = "cluster.ids")

# enumerate current cluster IDs and the labels for them
cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
free_annotation = c(NA,NA,NA,NA,NA,NA,"excitatory neurons and some neuronal stemm cells",NA,
                    NA,"inhibitory neurons")

cell_ontology_class <-
  c(
    "oligodendrocyte",
     "endothelial cell",
    "astrocyte",
     "oligodendrocyte",
     "oligodendrocyte precursor cell",
  "endothelial cell",
   "neuron",
   "oligodendrocyte",
  "brain pericyte",
   "neuron"
  )
  
tiss = stash_annotations(tiss, cluster.ids, free_annotation, cell_ontology_class)

# Replot TSNE plots
title <- "TSNE_plots_gene_expression_plus_cell_ontology_class.pdf"
TSNEPlot(object = tiss, do.label = T)
TSNEPlot(object = tiss, do.label = TRUE, pt.size = 0.5, group.by='cell_ontology_class')
```


Check the numbers of cells per cell_ontology_class
```{r}
table(tiss@meta.data$cell_ontology_class)
```



## Checking for batch effects


Color by metadata, like plate barcode, to check for batch effects.
```{r}
TSNEPlot(object = tiss, do.return = TRUE, group.by = "plate.barcode")
```

Print a table showing the count of cells in each identity category from each plate.

```{r}
table(as.character(tiss@ident), as.character(tiss@meta.data$plate.barcode))
```



# Subset and iterate

We can repeat the above analysis on a subset of cells, defined using cluster IDs or some other metadata. This is a good way to drill down and find substructure.

## First subset

```{r}
# Subset data based on cluster id
subtiss <- SubsetData(object = tiss, ident.use = c("2"), do.center = F, do.scale = F)
#suffix <- "neurons"

# To subset data based on cell_ontology_class or other metadata, you can explicitly pass cell names
# anno = 'exocrine cells'
# cells.to.use = tiss@cell.names[which(tiss@meta.data$cell_ontology_class == anno)]
# subtiss <- SubsetData(object = tiss, cells.use = cells.to.use, do.center = F, do.scale = F)

```

```{r}
subtiss <- NormalizeData(object = subtiss, scale.factor = 1e6)
subtiss <- ScaleData(object = subtiss)
subtiss <- FindVariableGenes(object = subtiss, do.plot = TRUE, x.high.cutoff = Inf, y.cutoff = 0.5)
```

```{r}
subtiss <- FindVariableGenes(object = subtiss, do.plot = TRUE, x.high.cutoff = Inf, y.cutoff = 0.8)
subtiss <- RunPCA(object = subtiss, pcs.compute = 20, do.print = F)
subtiss <- ProjectPCA(object = subtiss, do.print = FALSE)
```


Run Principal Component Analysis.
```{r}
subtiss <- RunPCA(object = subtiss, do.print = FALSE)
subtiss <- ProjectPCA(object = subtiss, do.print = FALSE)
```

```{r}
# If this fails for your subset, it may be that cells.use is more cells than you have left! Try reducing it.
PCHeatmap(object = subtiss, pc.use = 1:3, cells.use = 100, do.balanced = TRUE, label.columns = FALSE, num.genes = 12)
```

Later on (in FindClusters and TSNE) you will pick a number of principal components to use. This has the effect of keeping the major directions of variation in the data and, ideally, supressing noise. There is no correct answer to the number to use, but a decent rule of thumb is to go until the plot plateaus.

```{r}
PCElbowPlot(object = subtiss)
```

Choose the number of principal components to use.
```{r}
# Set number of principal components. 
sub.n.pcs = 10
```


The clustering is performed based on a nearest neighbors graph. Cells that have similar expression will be joined together. The Louvain algorithm looks for groups of cells with high modularity--more connections within the group than between groups. The resolution parameter determines the scale...higher resolution will give more clusters, lower resolution will give fewer.

```{r}
# Set resolution 
sub.res.used <- 1

subtiss <- FindClusters(object = subtiss, reduction.type = "pca", dims.use = 1:sub.n.pcs, 
    resolution = sub.res.used, print.output = 0, save.SNN = TRUE, force.recalc = TRUE)
```

To visualize 
```{r}
# If cells are too spread out, you can raise the perplexity. If you have few cells, try a lower perplexity (but never less than 10).
subtiss <- RunTSNE(object = subtiss, dims.use = 1:sub.n.pcs, seed.use = 10, perplexity=40)
```

```{r}
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = subtiss, do.label = T)
TSNEPlot(object = subtiss, group.by="plate.barcode")
TSNEPlot(object = subtiss, group.by='subtissue')
TSNEPlot(object = subtiss, group.by='mouse.id')

```



```{r Write top 50 markers for each subcluster}
subtiss.markers <- FindAllMarkers(object = subtiss, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
top <- subtiss.markers %>% group_by(cluster) %>% top_n(50, avg_logFC)
# write.table(top)
```

Check expression of genes of interset.
```{r}
genes_to_check = c("Slc1a3", "Aldh1l1", "Aqp4","A2m","Nbl1","Gdf10","Naga","Tnfaip2","St6galnac5","Nsdhl")
#top <- subtiss.markers %>% group_by(cluster) %>% top_n(2, avg_diff)
DotPlot(subtiss, genes_to_check, plot.legend = T, col.max = 2.5, do.return = T) + coord_flip()

```

Dotplots let you see the intensity of exppression and the fraction of cells expressing for each of your genes of interest.


How big are the clusters?
```{r}
table(subtiss@ident)
```

## Checking for batch effects

Color by metadata, like plate barcode, to check for batch effects.
```{r}
TSNEPlot(object = subtiss, do.return = TRUE, group.by = "plate.barcode")
TSNEPlot(object = subtiss, do.return = TRUE, group.by = "res.1")
```

Print a table showing the count of cells in each identity category from each plate.

```{r}
table(as.character(subtiss@ident), as.character(subtiss@meta.data$plate.barcode))
```



### Assigning subcell_ontology_classs

For the subsets, we produce subcell_ontology_classs. These will be written back as metadata in the original object, so we can see all subcell_ontology_classs together.

If some of the clusters you find in the subset deserve additional cell_ontology_class, you can add that right here. Use NA for clusters for which no subcell_ontology_class is needed.

```{r}
sub.cluster.ids <- c(0, 1, 2, 3,4)
sub.free_annotation <- c(NA,NA,NA,NA,NA)
sub.cell_ontology_class <-c("astrocyte of the cerebral cortex","astrocyte of the cerebral cortex","astrocyte of the cerebral cortex",
                   "astrocyte of the cerebral cortex","Bergmann glial cell")

subtiss = stash_annotations(subtiss, sub.cluster.ids, sub.free_annotation, sub.cell_ontology_class)
tiss = stash_subtiss_in_tiss(tiss, subtiss)

TSNEPlot(object = subtiss, do.label = TRUE, pt.size = 0.5, group.by='cell_ontology_class')
```


Check the numbers of cells per cell_ontology_class
```{r}
table(tiss@meta.data$cell_ontology_class)
```



When you save the annotated tissue, please give it a name.

```{r}
filename = here('00_data_ingest', '04_tissue_robj_generated', 
                     paste0("facs_", tissue_of_interest, "_seurat_tiss.Robj"))
print(filename)
save(tiss, file=filename)
```


# Export the final metadata

So that Biohub can easily combine all your cell_ontology_classs, please export them as a simple csv.

```{r}
head(tiss@meta.data)
```


```{r}
filename = here('00_data_ingest', '03_tissue_cell_ontology_class_csv', 
                     paste0(tissue_of_interest, "_cell_ontology_class.csv"))
write.csv(tiss@meta.data[,c('plate.barcode','cell_ontology_class','cell_ontology_id')], file=filename)
```

Write the cell ontology and free annotations to CSV.

```{r}
save_annotation_csv(tiss, tissue_of_interest, "facs")
```








# Subsetting of brain endothelial cells and analysis using robust PCA followed by Seurat

Filter for all endothelial cells from whole brain (non-microglia) annotation
```{r}
endo.sub<-tiss@raw.data[, grep("endothelial",tiss@meta.data$cell_ontology_class)]
endo<-grep("endothelial",tiss@meta.data$cell_ontology_class)
endo.sub.names<-colnames(tiss@scale.data)[endo] 
endo.sub<-tiss@raw.data[,endo.sub.names] 

```

Load packages
```{r}
library(dplyr)
library(Matrix)
library(cowplot)
require(RColorBrewer)
```

Required custom functions
```{r}

# return minimum (most negative) correlation value for each gene
get.gene.cor <- function(data, min.cells.expr = 1) {
  mat = t(data[, colSums(data > 0) > min.cells.expr]) # filter genes 
  mat = mat - rowMeans(mat)
  cr = tcrossprod( mat/sqrt(rowSums(mat^2)) )  
  return(cr)
}
get.min.cor <- function(data, min.cells.expr = 1) {
  require(matrixStats)
  cr = get.gene.cor(data, min.cells.expr)
  min.cor = colMins(cr, na.rm =T)
  names(min.cor) = colnames(cr)
  return(min.cor)
}


## robust PCA function
do.robpca <- function(data.counts,min_cells=0,min_sd=0,ncp=10,expression.values="log10.cpm",from.mat = T,...){
  require(rrcov)
  if(!from.mat){
    if(min_cells>0){
      data<-filter.genes(data.counts,expression.values,min_sd,min_cells)  
    } else{ cast.counts <- cast.to.df(data.counts,expression.values) }
  } else {
    cast.counts = data.counts[, colSums(data.counts > 0) > min_cells]
  }
  print('starting rPCA')
  pca <- PcaHubert(cast.counts, k = ncp,kmax=ncp,...)
  rm(cast.counts);gc()
  scores <- as.data.frame(getScores(pca));scores$cell.name <- rownames(scores); scores <- data.table(scores);setkey(scores)
  var   <- as.data.frame(getLoadings(pca)); var$gene <- rownames(var);var <- as.data.table(var);setkey(var)
  gc()
  list(pca, scores, var)
}

filter.genes <- function(data.counts,expression.value="log10.cpm",min_sd=0,min_cells=0){
  data=copy(data.counts);
  data[,numcells_exp:=sum(get(expression.value)>0),by=gene]; data<-data[numcells_exp>min_cells]
  data[,gene_sd:=sd(get(expression.value)),by=gene]; data<-data[gene_sd>min_sd]
  data
}


## cast to dataframe function
cast.to.df <- function(data.counts,expression.values="log10.cpm",annot="none", to.matrix = F, genes.use = NULL){
  if(!is.null(genes.use)) data.counts = data.counts[gene %in% genes.use]
  if(annot != "none"){
    cast.counts <- dcast.data.table(data.counts, cell.name ~ gene, value.var=expression.values, fill = 0)
    setkey(data.counts)
    cast.counts <- merge(cast.counts,unique(data.counts[,.(cell.name,get(annot))]),by="cell.name")
    setnames(cast.counts,c(colnames(cast.counts)[1:(ncol(cast.counts)-1)],annot))
    cast.counts <- as.data.frame(cast.counts)
  }
  else{
    cast.counts <- as.data.frame(dcast.data.table(data.counts, cell.name ~ gene, value.var=expression.values,fill=0))  
    gc()
  }
  rownames(cast.counts)<-cast.counts$cell.name; cast.counts <- cast.counts[,c(ncol(cast.counts),2:(ncol(cast.counts)-1))]
  if(to.matrix) cast.counts = as.matrix(cast.counts)
  cast.counts
}


```



QC
```{r}
ECs<-CreateSeuratObject(raw.data=endo.sub, min.cells=5, min.genes=5) # already filter zero count genes
colnames(ECs@meta.data)[colnames(ECs@meta.data)=='nUMI']<-'nReads' ##change name

#Add ribo data
ribo.genes<-grep(pattern="^Rp[s1][[:digit:]]", x=rownames(x=ECs@data), value=TRUE) ##60
percent.ribo<-Matrix::colSums(ECs@raw.data[ribo.genes, ])/Matrix::colSums(ECs@raw.data)
ECs <- AddMetaData(object = ECs, metadata = percent.ribo, col.name = "percent.ribo")

#Add mito data
mito.genes <- grep(pattern = "^mt-", x = rownames(x = ECs@data), value = TRUE)
percent.mito <- Matrix::colSums(ECs@raw.data[mito.genes, ])/Matrix::colSums(ECs@raw.data)
ECs <- AddMetaData(object = ECs, metadata = percent.mito, col.name = "percent.mito")

GenePlot(object = ECs, gene1 = "nReads", gene2 = "nGene")

ECs <- FilterCells(object = ECs, subset.names = c("nGene", "nReads"), low.thresholds = c(200, 20000), high.thresholds = c(25000, Inf)) 
ECs <- NormalizeData(object = ECs)
ECs <- ScaleData(object = ECs) 

```


Add brain region information in metadata
```{r}

DF<-as.data.frame(cbind(tiss@cell.names, as.character(tiss@meta.data$subtissue)))
rownames(DF)<-DF$V1
ECs@meta.data$subtissue<-as.character(DF[ECs@cell.names, 2])

```


Feature selection: perform robust PCA on top 2500 most anti-correlated genes

```{r}

data.pca <- t(log2(1+1e6*(t(t(ECs@raw.data)/colSums(ECs@raw.data))))) ##log 2 normalize data
gene.min.cors <- get.min.cor(data.pca, min.cells.expr = 2)
genes.use <- names(sort(gene.min.cors)[1:2500])

# Remove some housekeeping genes
genes.use <- genes.use[grep('^Rp[ls].*', genes.use, invert = T)]
genes.use <- genes.use[grep('Rn45s', genes.use, invert = T)]
genes.use <- genes.use[grep('Lars2', genes.use, invert = T)]
genes.use <- genes.use[grep('Malat1', genes.use, invert = T)]

ncp=20
num.sig.genes <- 30

pcalist <- do.robpca(data.pca[, genes.use],ncp = ncp, from.mat = T) 
loadings <- pcalist[[3]] 
sdev<-pcalist[[1]]
sdev<-sdev@sd
data.scaled<-t(t(data.pca[,genes.use]) / colMaxs(data.pca[,genes.use])) 

library(pbapply)
dims <- paste0('PC', 1:ncp) ## 1:20
pc.sigs <- as.data.frame(do.call(cbind, lapply(dims, function(dim) {
  setorderv(loadings,dim,-1)
  genes.pos <- loadings[,gene][1:num.sig.genes]
  setorderv(loadings,dim,1)
  genes.neg <- loadings[,gene][num.sig.genes:1]
  cast.sig <- as.data.frame(cbind(rowSums(data.scaled[, genes.pos]), rowSums(data.scaled[, genes.neg]))) 
  print(head(cast.sig))
  cast.sig$pc.score <- cast.sig[, 1] - cast.sig[, 2]
  colnames(cast.sig) <- c(paste0(dim,'.pos'), paste0(dim,'.neg'), dim)
  return(as.matrix(cast.sig))
  }
)))

pc.sigs <- pc.sigs[match(ECs@cell.names, rownames(pc.sigs)), ]
pc.sigs <- as.matrix(pc.sigs[, grepl("PC[0-9]+$", colnames(pc.sigs))]) 
ECs <- SetDimReduction(ECs, 'pca', 'cell.embeddings', new.data = pc.sigs)
pc.loadings<-loadings[,1:20]
pc.loadings<-as.matrix(pc.loadings)
rownames(pc.loadings)<-loadings$gene
ECs <- SetDimReduction(ECs, 'pca', 'gene.loadings', new.data = pc.loadings)
ECs@dr$pca@key<-"PC"

```



Plug the cell.embeddings and gene.loadings from rPCA back into Seurat object and run Seurat clustering
```{r}

ECs <- FindClusters(object = ECs, reduction.type = "pca", dims.use = 1:15, 
    resolution = 1, print.output = 0, save.SNN = TRUE, force.recalc = T) 

ECs <- RunTSNE(object = ECs, dims.use = 1:8, seed.use = 10, check_duplicates = F, perplexity=40)

# unsupervised clustering
TSNEPlot(object = ECs, do.label = T, label.size = 6, pt.size = 3.1, colors.use = brewer.pal(11,'Paired'), do.return=TRUE) + labs(x = "tSNE 1", y="tSNE 2")+ theme(axis.title.x = element_text(colour = "black", size=16), axis.title.y = element_text(colour = "black", size=16), legend.text=element_text(size=13))

#annotated by brain subregion
TSNEPlot(object = ECs, do.label = T, label.size = 6, pt.size = 3.1, colors.use = brewer.pal(9,'Set1'), do.return=TRUE, group.by="subtissue") + labs(x = "tSNE 1", y="tSNE 2")+ theme(axis.title.x = element_text(colour = "black", size=16), axis.title.y = element_text(colour = "black", size=16), legend.text=element_text(size=13))


PCHeatmap(object = ECs, pc.use = 1:12, cells.use = 300, do.balanced = TRUE, label.columns = FALSE, num.genes = 20)
PCAPlot(object = ECs, dim.1 = 1, dim.2 = 2, pt.size = 2)


#violin plots of key defining genes for the Inflamed (Venous) and Notch (Arterial) populations
genes_check<-c('Vcam1','Icam1','Lcn2','Hif1a','Vwf','Csf1','Notch1','Hey1','Vegfc','Edn1','Tmem100')
FeaturePlot(ECs, features.plot=genes_check, pt.size = 2, no.axes = T, cols.use = c("lightgray", "red"), dark.theme = F)


VlnPlot(object = ECs, features.plot = genes_check, do.sort=F, size.title.use = 18, size.x.use = 0.3,size.y.use = 3, cols.use = brewer.pal(11,'Paired'), point.size.use = 0.3)


```


Find differentially expressed genes between clusters
```{r}


DE_markers <- mclapply(levels(ECs@ident),  function(x) {
  df <- FindMarkers(object = ECs, ident.1 = x, only.pos = TRUE, min.pct = 0.20, thresh.use = 0.20)
  df$gene <- rownames(df)
  df$cluster <- x
  return(df)
  }, mc.cores = 2)
DE_markers <- bind_rows(DE_markers)

DE_markers <- DE_markers[DE_markers$p_val<0.05, ]
DE_markers_sorted <- DE_markers %>% group_by(cluster) %>% top_n(10, avg_diff)


DoHeatmap(object = ECs, genes.use = DE_markers_sorted$gene, slim.col.label = TRUE, remove.key = FALSE, cex.row = 7) 


```



#renaming cluster for function AND segmental identity based on differentially expressed genes
```{r}

current.cluster.ids <- c(0, 1, 2, 3, 4)
new.cluster.ids <- c("Capillary/BBB-maintenance", "Capillary/BBB-maintenance","Arterial/Notch-signaling", "Capillary/BBB-maintenance", "Venous/inflammatory")
ECs@ident <- plyr::mapvalues(x = ECs@ident, from = current.cluster.ids, to = new.cluster.ids)
ECs<-StashIdent(object=ECs, save.name="Annotation") ## for more clusters


TSNEPlot(object = ECs, do.label = T, pt.size = 3, colors.use = brewer.pal(8,'Set2'), do.return=TRUE) + labs(x = "tSNE 1", y="tSNE 2")+ theme(axis.title.x = element_text(colour = "black", size=16), axis.title.y = element_text(colour = "black", size=16), legend.text=element_text(size=13))


```


Make Dot plot based top defining genes for each annotated endothelial cluster
```{r}

features.plot <- c("Vwf","Flt4","Nr2f2","Ephb4","Car4","Slc16a1","Tfrc","Efnb2","Jag1","Bmx")
DotPlot(object = ECs, genes.plot = features.plot, plot.legend = TRUE,group.by = "Annotation", x.lab.rot = T)


```